{
  "name": "person-VanillaJS",
  "version": "1.0.0",
  "description": "CRUD operation on person in memory object\r Description\r Your task is to implement simple CRUD API using in-memory database underneath.\r Technical requirements\r •\tTask can be implemented on Javascript or Typescript\r •\tUse 18 LTS version of Node.js\r •\tPrefer asynchronous API whenever possible\r •\tUpload your code to GitHub, GitLab, BitBucket, or similar hosting services with full commit history\r •\tRequirements 1-5 are mandatory\r •\tComplete Requirements 6-8 for bonus points\r Implementation details\r 1.\tImplemented endpoint api/users: \r o\tGET api/users is used to get all persons \r \tServer should answer with status code 200 and all users records\r o\tGET api/users/{userId} \r \tServer should answer with status code 200 and record with id === userId if it exists\r \tServer should answer with status code 400 and corresponding message if userId is invalid (not uuid)\r \tServer should answer with status code 404 and corresponding message if record with id === userId doesn't exist\r o\tPOST api/users is used to create record about new user and store it in database \r \tServer should answer with status code 201 and newly created record\r \tServer should answer with status code 400 and corresponding message if request body does not contain required fields\r o\tPUT api/users/{userId} is used to update existing user \r \tServer should answer with status code 200 and updated record\r \tServer should answer with status code 400 and corresponding message if userId is invalid (not uuid)\r \tServer should answer with status code 404 and corresponding message if record with id === userId doesn't exist\r o\tDELETE api/users/{userId} is used to delete existing user from database \r \tServer should answer with status code 204 if the record is found and deleted\r \tServer should answer with status code 400 and corresponding message if userId is invalid (not uuid)\r \tServer should answer with status code 404 and corresponding message if record with id === userId doesn't exist\r 2.\tUsers are stored as objects that have following properties: \r o\tid — unique identifier (string, uuid) generated on server side\r o\tusername — user's name (string, required)\r o\tage — user's age (number, required)\r o\thobbies — user's hobbies (array of strings or empty array, required)\r 3.\tRequests to non-existing endpoints (e.g. some-non/existing/resource) should be handled (server should answer with status code 404 and corresponding human-friendly message)\r 4.\tErrors on the server side that occur during the processing of a request should be handled and processed correctly (server should answer with status code 500 and corresponding human-friendly message)\r 5.\tValue of port on which application is running should be stored in .env file\r Bonus Points\r 6.\tThere should be 2 modes of running application (development and production): \r o\tThe application is run in development mode using nodemon or ts-node-dev (there is a npm script start:dev)\r o\tThe application is run in production mode (there is a npm script start:prod that starts the build process and then runs the bundled file)\r 7.\tThere could be some tests for API (not less than 3 scenarios). Example of test scenario: \r o\tGet all records with a GET api/users request (an empty array is expected)\r o\tA new object is created by a POST api/users request (a response containing newly created record is expected)\r o\tWith a GET api/user/{userId} request, we try to get the created record by its id (the created record is expected)\r o\tWe try to update the created record with a PUT api/users/{userId}request (a response is expected containing an updated object with the same id)\r o\tWith a DELETE api/users/{userId} request, we delete the created object by id (confirmation of successful deletion is expected)\r o\tWith a GET api/users/{userId} request, we are trying to get a deleted object by id (expected answer is that there is no such object)\r 8.\tThere could be implemented horizontal scaling for application, there should be npm script start:multi that starts multiple instances of your application using the Node.js Cluster API (equal to the number of available parallelism - 1 on the host machine, each listening on port PORT + n) with a load balancer that distributes requests across them (using Round-robin algorithm). For example: available parallelism is 4, PORT is 4000. On run npm run start:multi it works following way\r •\tOn localhost:4000/api load balancer is listening for requests\r •\tOn localhost:4001/api, localhost:4002/api, localhost:4003/api workers are listening for requests from load balancer\r •\tWhen user sends request to localhost:4000/api, load balancer sends this request to localhost:4001/api, next user request is sent to localhost:4002/api and so on.\r •\tAfter sending request to localhost:4003/api load balancer starts from the first worker again (sends request to localhost:4001/api)\r •\tState of db should be consistent between different workers, for example: \r 1.\tFirst POST request addressed to localhost:4001/api creates user\r 2.\tSecond GET request addressed to localhost:4002/api should return created user\r 3.\tThird DELETE request addressed to localhost:4003/api deletes created user\r 4.\tFourth GET request addressed to localhost:4001/api should return 404 status code for created user",
  "main": "index.js",
  "scripts": {
    "start:dev": "nodemon src/app.js",
    "start:prod": "nodemon src/app.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/shiva-kant-mishra/person-VanillaJS.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/shiva-kant-mishra/person-VanillaJS/issues"
  },
  "homepage": "https://github.com/shiva-kant-mishra/person-VanillaJS#readme",
  "dependencies": {
    "nodemon": "^3.0.2"
  }
}
